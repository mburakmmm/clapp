# .cursorrules for pypi_packaging (YAML format)

module: pypi_packaging

description: |
  This module defines the configuration and metadata needed to publish clapp to the Python Package Index (PyPI).
  It includes `setup.py`, metadata, entry points, and package structure conventions.


development_goals:
  - Prepare clapp for installation via `pip install clapp`
  - Define a console script entry point for `clapp`
  - Ensure proper packaging of all source modules and assets

required_files:
  - setup.py
  - README.md
  - LICENSE
  - MANIFEST.in (optional)
  - requirements.txt

setup_py_structure:
  name: clapp
  version: "0.1.0"
  description: "Lightweight cross-language app manager for Python and Lua"
  author: "Melih Burak Memiş"
  author_email: "burak@example.com"
  url: "https://github.com/mburakmmm/clapp"
  packages: use setuptools.find_packages()
  include_package_data: true
  install_requires:
    - flet
    - other runtime deps...
  entry_points:
    console_scripts:
      - clapp=main_cli_entry:main

usage:
  publish_to_testpypi:
    - python setup.py sdist bdist_wheel
    - twine upload --repository testpypi dist/*

  publish_to_pypi:
    - twine upload dist/*

future_extensions:
  - Switch to pyproject.toml + poetry
  - Add `extras_require` for optional GUI
  - Integrate `clapp.gui` launch shortcut
  - Use `data_files` or `package_data` for GUI assets

# .cursorrules for platform_packaging (YAML format)

module: platform_packaging

description: |
  This module defines rules and strategies for packaging the clapp application into native executables
  for Windows, macOS, and Linux. It focuses on converting the Python project into standalone binaries
  using tools like PyInstaller or Flet Build.


development_goals:
  - Build `.exe` file for Windows
  - Build `.app` bundle for macOS
  - Build `.AppImage` or `.deb` for Linux
  - Ensure CLI and GUI entry points are both included

build_tools:
  - PyInstaller
  - Flet CLI (`flet build`)
  - Briefcase (optional)

platforms:
  - Windows:
      target: clapp.exe
      method: pyinstaller
      entry_script: main.py
      notes:
        - Add console=False for GUI version
        - Use --noconfirm --onefile options

  - macOS:
      target: clapp.app
      method: pyinstaller or briefcase
      entry_script: main_gui_entry.py
      notes:
        - GUI apps should use `windowed=True`
        - Codesigning required for notarized apps (optional)

  - Linux:
      target: clapp.AppImage or clapp.deb
      method: pyinstaller or AppImageKit
      entry_script: main.py
      notes:
        - CLI works out of the box
        - GUI builds may require GTK or Qt backend packaging

common_steps:
  - Create a `build/` folder
  - Write a spec file if needed for PyInstaller customization
  - Test builds on clean virtual machines

future_extensions:
  - Automate build process using GitHub Actions
  - Add platform-specific icons and splash screens
  - Create installer wizards (NSIS for Windows, DMG for macOS)

# .cursorrules for check_env (YAML format)

module: check_env

description: |
  This module provides a diagnostic command `clapp check-env` to help users verify that their environment
  is correctly set up to use clapp. It checks Python version, key paths, and console availability.


development_goals:
  - Check if Python version is >= 3.8
  - Check if `clapp` is discoverable in PATH
  - Check if user’s OS and platform-specific folders are accessible
  - Print detailed results with suggestions if anything is wrong

imports:
  - os
  - sys
  - shutil
  - platform

functions:
  - name: run_environment_check
    description: Runs all environment checks and prints a summary
    logic:
      - Check Python version: >= 3.8
      - Check if 'clapp' is in PATH using `shutil.which("clapp")`
      - Print detected OS (Windows/macOS/Linux)
      - Print location of Python binary and current working directory
      - If errors exist, print clear instructions to fix PATH

cli_command:
  - clapp check-env

future_extensions:
  - Check if `~/.local/bin` or Windows Scripts folder is in PATH
  - Offer to add missing path entries automatically (with confirmation)
  - Export full report to file (e.g., `clapp_env_report.txt`)

# .cursorrules for post_install_hint (YAML format)

module: post_install_hint

description: |
  This module displays helpful guidance after the user installs or runs clapp for the first time.
  It checks whether PATH issues are likely to occur and provides platform-specific instructions.


development_goals:
  - Automatically show a helpful message if `clapp` is not in system PATH
  - Suggest user to run `clapp check-env` for detailed diagnostics
  - Print platform-specific export or set commands
  - Only show message once or if issue is detected

imports:
  - os
  - sys
  - shutil
  - platform

functions:
  - name: show_post_install_hint
    description: Show warning or info after install or run, if needed.
    logic:
      - Use `shutil.which("clapp")` to detect if command is globally available
      - If not in PATH:
          - Print message like "clapp is not in your PATH"
          - Suggest command based on platform:
              - Windows → SET PATH manually or add Scripts\ to Env Vars
              - macOS/Linux → `export PATH=$PATH:~/.local/bin`
      - Suggest `clapp check-env` for full check

usage:
  used_by:
    - main.py (after initial run)
    - setup/post-install scripts

future_extensions:
  - Store `.clapp/.onboarded` file to suppress hint after first time
  - Integrate GUI onboarding popup
  - Show localized instructions (tr/en)

# .cursorrules for main.py (CLI entry point)

module: main_cli_entry

description: |
  This is the main entry point for the clapp CLI interface.
  It uses argparse to route top-level commands (run, list, install, upgrade, publish, check-env)
  to their corresponding internal functions and includes onboarding hint.


development_goals:
  - Centralize CLI routing in a single file
  - Support local commands (run, list) and remote/package commands (install, upgrade, publish)
  - Integrate onboarding experience and environment check

imports:
  - argparse
  - clapp_core
  - cli_commands
  - check_env
  - post_install_hint

functions:
  - name: main
    description: Parses CLI arguments and dispatches to appropriate command function.
    logic:
      - Show onboarding hint using `post_install_hint.show_post_install_hint()`
      - Setup argparse with subparsers:
          - run <app_name>
          - list
          - install <app_name>
          - upgrade <app_name>
          - publish <folder_path>
          - check-env
      - Match command and call:
          - run → clapp_core.run_app(app_name)
          - list → clapp_core.list_apps()
          - install → cli_commands.install_from_remote(app_name)
          - upgrade → cli_commands.upgrade_package(app_name)
          - publish → cli_commands.publish_package(folder_path)
          - check-env → check_env.run_environment_check()
      - If unknown or incomplete command, print help

entry_point:
  - if __name__ == "__main__": main()

future_extensions:
  - Add global flags (e.g., --debug, --no-color)
  - Hook into GUI from CLI with `--gui`
  - Add auto-completion or fuzzy matching for commands

# .cursorrules for info_command (YAML format)

module: info_command

description: |
  This module defines the `clapp info <app_name>` command, which displays detailed information about a local app,
  including version, language, description, entry file, and file path.


development_goals:
  - Load manifest.json from the app’s installed folder
  - Parse and display relevant metadata (name, version, language, entrypoint)
  - Validate presence of manifest.json and provide graceful error messages

usage:
  - clapp info <app_name>

manifest_fields_to_show:
  - name
  - version
  - language
  - description
  - entry_file
  - dependencies

fallback_behavior:
  - If manifest.json is missing: print "No manifest found for this app."
  - If app does not exist: print "App '<name>' is not installed."

imports:
  - os
  - json
  - clapp_utils

functions:
  - name: show_app_info
    description: Finds the manifest of the app and displays metadata in formatted style
    logic:
      - Locate the installed app folder
      - Open and parse manifest.json
      - Print selected metadata fields with labels
      - Highlight missing or unknown values in yellow

future_extensions:
  - Support remote package info lookup (registry metadata)
  - Format output in table or GUI card (for GUI reuse)
  - Add license and author fields

# .cursorrules for validate_command (YAML format)

module: validate_command

description: |
  This module defines the `clapp validate <folder>` command, which verifies that a given app folder
  is structured correctly and contains a valid manifest.json.


development_goals:
  - Ensure `manifest.json` exists in the specified folder
  - Parse and validate all required fields in the manifest
  - Check for existence of entry point file listed in manifest
  - Print warnings or errors for any inconsistencies

usage:
  - clapp validate ./myapp

required_manifest_fields:
  - name
  - version
  - language
  - entry_file

validation_steps:
  - Check if `manifest.json` exists
  - Load and parse JSON content
  - Validate presence and format of required fields
  - Check if `entry_file` exists in folder

error_handling:
  - If folder does not exist → print "Folder not found."
  - If manifest is missing → print "Missing manifest.json."
  - If fields are invalid → print each issue with suggestions

imports:
  - os
  - json
  - clapp_utils

functions:
  - name: validate_app_folder
    description: Validates app structure and manifest against expected rules
    logic:
      - Load folder and check for manifest
      - Parse and validate fields
      - Show success or list of validation issues

future_extensions:
  - Add `--strict` mode for extended validation
  - Support schema versioning
  - Integrate with scaffold/init to offer real-time feedback

# .cursorrules for doctor_command (YAML format)

module: doctor_command

description: |
  This module defines the `clapp doctor` command, which performs a comprehensive environment and setup diagnostic.
  It combines checks from `check-env`, file system access, folder integrity, and permission issues.


development_goals:
  - Provide user-friendly diagnostic of their clapp environment
  - Check Python version, PATH, installed app folder existence, write permissions
  - Report any warnings or errors with suggested fixes

usage:
  - clapp doctor

checks:
  - Python version >= 3.8
  - `clapp` is in PATH
  - User has write access to clapp apps directory (e.g., ~/.clapp/apps)
  - `~/.local/bin` or Scripts folder is in PATH (for command recognition)
  - Check if `clapp_config.json` or required folders are accessible

output:
  - Friendly formatted report:
      - ✅ for passed checks
      - ⚠️ for warnings
      - ❌ for failed checks with explanations

imports:
  - os
  - sys
  - shutil
  - platform
  - pathlib

functions:
  - name: run_doctor
    description: Perform all environment and system diagnostics
    logic:
      - Reuse `check_env` logic
      - Test write permission in app install dir
      - Print results for each step with emoji indicator

future_extensions:
  - Export diagnostics to file (e.g., clapp_diagnostics.txt)
  - Add `--fix` option to auto-correct common problems (e.g., add to PATH)
  - Integrate GUI-based diagnostics panel

# .cursorrules for clean_command (YAML format)

module: clean_command

description: |
  This module defines the `clapp clean` command, which removes temporary files, logs,
  cache folders, and old versions of apps (if present).


development_goals:
  - Delete temporary build folders and logs under ~/.clapp/temp or ~/.clapp/logs
  - Remove any leftover `.zip` or `.old` files in app install directory
  - Free up space by cleaning unused remnants

usage:
  - clapp clean

clean_targets:
  - ~/.clapp/temp
  - ~/.clapp/logs
  - ~/.clapp/apps/*/*.zip
  - ~/.clapp/apps/*/*.old

output:
  - Print number of files deleted and space reclaimed
  - Show summary per folder

imports:
  - os
  - shutil
  - glob
  - pathlib

functions:
  - name: run_clean
    description: Deletes all temporary and outdated files in clapp's working directories
    logic:
      - Loop through each clean target
      - Delete matching files/folders if they exist
      - Tally file count and total size removed
      - Print final cleanup summary

future_extensions:
  - Add `--dry-run` mode to preview deletions
  - Add `--apps <name>` flag to clean only specific app artifacts
  - GUI integration: cleanup button under settings

# .cursorrules for where_command (YAML format)

module: where_command

description: |
  This module defines the `clapp where <app_name>` command, which shows the full
  file system path of the installed application and optionally validates its existence.


development_goals:
  - Locate and print the full path to the installed app folder
  - Confirm that the folder exists
  - Optionally validate if the entry file is present

usage:
  - clapp where <app_name>

logic:
  - Check default app install directory (e.g., ~/.clapp/apps/<app_name>)
  - If exists, print the path
  - If not found, print friendly warning

fallback_behavior:
  - If app is not installed → print "App '<name>' not found."

optional_flags:
  - `--check-entry` → Checks if entry_file exists based on manifest.json

imports:
  - os
  - json
  - pathlib

functions:
  - name: locate_app_path
    description: Locates and prints the app install directory, optionally checking for entry point
    logic:
      - Build expected path
      - If directory exists, print it
      - If --check-entry is passed, load manifest and confirm entry file exists

future_extensions:
  - Add `--open` flag to open folder in file explorer
  - Add GUI button: “Go to folder”

# .cursorrules for version_command (YAML format)

module: version_command

description: |
  This module defines the `clapp version` command, which displays the current installed version of clapp.
  It can be called from CLI or embedded into GUI About section.


development_goals:
  - Print the current clapp version from a central source (e.g., __version__.py)
  - Support `--short` or `--json` options

usage:
  - clapp version
  - clapp version --short
  - clapp version --json

version_source:
  - clapp/__version__.py or setup.py or pyproject.toml

output:
  - Default → "clapp v1.2.0 (Python 3.10, Platform: macOS)"
  - --short → "1.2.0"
  - --json → { "version": "1.2.0", "python": "3.10", "os": "macOS" }

imports:
  - platform
  - sys
  - clapp.__version__

functions:
  - name: print_version
    description: Display clapp version with optional format flags
    logic:
      - Load version string
      - Detect platform and Python version
      - Format output accordingly

future_extensions:
  - Integrate into GUI footer or About popup
  - Support `--latest` to check against remote version

main dosyasını ve cli help komutunu  yeni özelliklere göre düzenlemeyi unutma....